#!/usr/bin/env python

"""
Patch Installer for portable handheld devices running Knulli.
This script reads YAML patch definition files, checks requirements, and allows users to install patches
through a Pygame-based user interface. The script also handles patch file downloads, OS version checks, 
and logging to a file or console.
"""

import argparse
import logging
import pygame
import sys
import os
import shutil
import pathlib
import glob
import subprocess
import re
import yaml
import requests
import socket
import zipfile

VERSION = '1.4.5'

# UI color settings
BACKGROUND_COLOR = (0, 0, 0)         # Black background
NORMAL_TEXT_COLOR = (150, 150, 150)  # Gray for normal text
BOLD_TEXT_COLOR = (255, 255, 255)    # White for bold/selected text
HIGHLIGHT_COLOR = (68, 138, 255)     # Blue for highlighted selections
TITLE_TEXT_COLOR = (255, 255, 255)   # White for Title Text
TITLE_BG_COLOR = HIGHLIGHT_COLOR     # Use the same color as for highlighting for Title Background
SELECTION_BG_COLOR = NORMAL_TEXT_COLOR
SELECTION_TEXT_COLOR = BACKGROUND_COLOR

# UI layout constants
TITLE_HEIGHT = 40  # Height of the title bar
INSTRUCTIONS_HEIGHT = 40  # Height for instructions displayed on screen
FONT_SIZE = 28  # Base font size for text display
PADDING = 10  # Padding around UI elements
BORDER = 2  # Border width for highlighted items

PATCH_REPOSITORY = {
    'repository': 'zarquon-42/knulli-patch-installer',
    'path': 'patches'
}
SCRIPT_SOURCE_URL = f"https://raw.githubusercontent.com/{PATCH_REPOSITORY['repository']}/refs/heads/main/Patch-Installer.pygame"

PATCH_LIBRARY_PATH=f"{os.path.dirname(os.path.realpath(__file__))}/patches"
if '--test-mode' in sys.argv:
    PATCH_LIBRARY_PATH='/tmp/patches'

PERSONAL_PATCH_DIR = f"{os.path.expanduser('~')}/patches"

# Default log file path
DEFAULT_LOG_FILE = f"{os.path.expanduser('~')}/logs/patch-installer.log"
# Check if the directory for the default log file exists
if not os.path.exists(os.path.dirname(DEFAULT_LOG_FILE)):
    DEFAULT_LOG_FILE = os.path.abspath(f"{os.path.dirname(os.path.realpath(__file__))}/patch-installer.log")

log_levels = {
    0: logging.CRITICAL,
    1: logging.WARNING,
    2: logging.INFO,
    3: logging.DEBUG
}

def initialize_logging(log_file, log_level=2):
    """
    Initializes the logging system. Logs messages to both a log file and the console
    depending on the provided log level. Log levels:
    0: CRITICAL, 1: WARNING, 2: INFO, 3: DEBUG
    """

    # Add a console handler for real-time log output to the console at the specified level.
    logging.basicConfig(
        filename=log_file,
        filemode='a',  # Append to the file
        level=log_levels[log_level],
        format='%(asctime)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )

    # Also output to console at the same level
    console = logging.StreamHandler()
    console.setLevel(log_levels[log_level])
    logging.getLogger().addHandler(console)

    logging.debug(f"Log initialized at level: {log_levels[log_level]}")
    logging.debug(f"Logging to file: {log_file}")

def adjust_logging(log_level=2):
    # Adjusts the logging level on the fly based on log_level.
    logging.setLevel(log_levels[log_level])

def trim_logfile(log_file):
    try:
        run_command(f"tail -200 {log_file} > /tmp/patch-installer.log && rm {log_file} && mv /tmp/patch-installer.log {log_file}")
    except:
        logging.warning("Problem trimming log file.\n{e=}, {type(e)=}")

def is_network_available(host="8.8.8.8", port=53, timeout=3):
    """
    Checks if the network is available by attempting to create a connection to a public DNS server.
    
    :param host: The host to connect to (default is Google's public DNS server).
    :param port: The port to use (default is 53, the DNS port).
    :param timeout: Timeout for the connection in seconds.
    :return: True if the network is available, False otherwise.
    """
    try:
        # Attempts a socket connection to check for network availability. Default connection to Google DNS.
        socket.create_connection((host, port), timeout=timeout)
        return True
    except OSError as e:
        logging.debug(f"Network check failed: {e}")
        return False
    except:
        logging.warning(f"Unhandled exception during network check: {e=}, {type(e)=}")
        return False

def version_tuple(version):
    """
    Converts a version string to a tuple for easy comparison (e.g., "1.4.1" -> (1, 4, 1)).
    Non-integer elements are assigned a high default to avoid incorrect comparisons.
    """

    # Helper function to replace non-integer values with a high number.
    # For example: 1.4.0b3 -> 1.4.9999
    def myint(a):
        if a.isdigit():
            return int(a)
        else:
            return 9999

    try:
        return tuple(map(myint, (version.split("."))))
    except:
        logging.error(f"Problem converting version number {version}")

    return (9999, 9999, 9999)

def run_command(command):
    """
    Executes a shell command, capturing both stdout and stderr. 
    Logs output or errors based on the command result. If an error occurs, logs the critical failure.
    """
    try:
        result = subprocess.run(
            command,
            shell=True,
            stdout = subprocess.PIPE,
            stderr = subprocess.PIPE,
            universal_newlines = True
        )
        if result.stdout: logging.debug(result.stdout)
        if result.stderr: logging.error(result.stderr)
    except Exception as e:
        logging.critical(f"Error occurred executing command \"{command}\" [{e=}, {type(e)=}]")
        result = None

    return result

def detect_os(return_raw=False):
    """
    Detects the OS version by running the 'batocera-version' command.
    The version is parsed into a numeric format to allow comparisons.
    """
    mocked = ""
    try:
        if return_raw:
            cmd = "batocera-version 2>/dev/null"
        else:
            cmd = "batocera-version 2>/dev/null | sed 's/.*\\([0-9][0-9][0-9][0-9]\\).\\([0-9][0-9]\\).\\([0-9][0-9]\\) .*/\\1\\2\\3/'"
        
        result = run_command(cmd)
        if result:
            version=result.stdout.strip()
    except:
        version = None

    if not version:
        if '--test-mode' in sys.argv:
            if return_raw:
                version = "mocked OS 20240721"
            else:
                version = "20240721"
            mocked = " mocked"
        else:
            version = "0"

    logging.debug(f"Detected OS: {version}{mocked}")

    return version

def os_check(requirements):
    """
    Checks if the OS version meets the specified requirements.
    Requirements are provided as a dictionary of comparison rules with operators (>, >=, <, <=, =, !=).
    Returns True if all requirements are met, False otherwise.
    """
    if "os" in requirements:
        os_version = detect_os()
        if os_version:
            rules = requirements['os']

            # Define the operator patterns
            operators = {
                '>': lambda x, y: x > y,
                '>=': lambda x, y: x >= y,
                '<': lambda x, y: x < y,
                '<=': lambda x, y: x <= y,
                '=': lambda x, y: x == y,
                '!=': lambda x, y: x != y,
            }
            
            # If no rules are supplied, return True
            if not rules:
                logging.debug(f"No Rules")
                return True, ""
            
            # Loop through each rule and check if OS version satisfies the condition
            for rule in rules:
                # Default operator is "=" if not specified
                match = re.match(r'(>=|<=|>|<|!=|=)?(\d+)', rule)
                if match:
                    operator, reference_version = match.groups()
                    operator = operator or '='  # Default to "=" if no operator is present
                    
                    # Convert versions to integers for comparison
                    os_ver = int(os_version)
                    ref_ver = int(reference_version)
                    
                    # Apply the operator and check the condition
                    if not operators[operator](os_ver, ref_ver):
                        return False, f"Patch does not match requirements: OS {os_version}{rule}"
    
    # If all rules are satisfied
    return True, ""

def installer_check(requirements):
    if "installer" in requirements:
        rules = requirements['installer']

        # Define the operator patterns
        operators = {
            '>': lambda x, y: x > y,
            '>=': lambda x, y: x >= y,
            '<': lambda x, y: x < y,
            '<=': lambda x, y: x <= y,
            '=': lambda x, y: x == y,
            '!=': lambda x, y: x != y,
        }
        
        # If no rules are supplied, return True
        if not rules:
            logging.info(f"No Rules")
            return True, ""
        
        # Parse the application version
        app_ver = version_tuple(VERSION)

        # Loop through each rule and check if the app version satisfies the condition
        for rule in rules:
            # Default operator is "=" if not specified
            match = re.match(r'(>=|<=|>|<|!=|=)?([\d\.]+)', rule)
            if match:
                operator, reference_version = match.groups()
                operator = operator or '='  # Default to "=" if no operator is present

                # Parse the reference version
                ref_ver = version_tuple(reference_version)

                # Apply the operator and check the condition
                if not operators[operator](app_ver, ref_ver):
                    return False, f"Patch does not match requirements: Patch installer {VERSION}{rule}"
        
    # If all rules are satisfied
    return True, ""

# Detect board type
def detect_board():
    mocked = ""
    try:
        result = run_command("batocera-info 2>/dev/null | grep '^Board: ' | sed -e 's/^Board: //' | tr '[:upper:]' '[:lower:]'")
        if result:
            board = result.stdout.strip()
    except Exception as e:
        logging.error(f"Error occurred retrieving board type {e=}, {type(e)=}")
        board = None

    if not board  and '--test-mode' in sys.argv:
        board = "rg40xx-v"
        mocked = " mocked"

    logging.debug(f"Detected board: {board}{mocked}")

    return board

def board_check(requirements):
    board_compatible = True
    return_msg = ""

    if 'boards' in requirements:
        compatible_boards = requirements['boards']
        board_compatible = False
    else:
        compatible_boards = None

    # Return True if no boards are defined (no constraints on compatibility)
    if compatible_boards:
        board = detect_board()
        if board:
            # Check each entry in boards (either a direct match or regex)
            for entry in compatible_boards:
                if entry == board or re.match(entry, board):
                    logging.debug(f"Board Check: Board ({board}) matches patch compatibility information ({entry})")
                    board_compatible = True
        else:
            logging.warning(f"Unable to determine board type")

        if not board_compatible:
            if not board:
                board = "unknown"
            return_msg = f"Patch not compatible with {board} board"
            logging.info(f"Skipping - incompatible with {board} board")
    else:
        logging.debug(f"Board Check: Patch does not contain any board compatibility information.  Assuming all boards OK")

    return board_compatible, return_msg

def get_disk_info(disk="/boot|/userdata|/media/"):
    try:
        result = run_command(f"df -hT | grep -E '{disk}'")
        disk_info = f"\n{result.stdout}"
    except:
        disk_info = None
    if (not disk_info) or disk_info == "":           
        disk_info = "Unavailable"

    return disk_info

# Check if a patch is compatible with the requirements)
def is_patch_compatible(patch):
    board_compatible = True
    os_compatible = True
    installer_compatible = True

    if 'requirements' in patch:
        requirements = patch['requirements']
    else:
        if "boards" in patch:
            requirements = patch
        else:
            requirements = None

    if requirements:
        logging.debug(f"Checking requirements for patch {patch['title']}")
        board_compatible, return_msg = board_check(requirements)
        if not board_compatible:
            return False, return_msg

        os_compatible, return_msg = os_check(requirements)
        if not os_compatible:
            logging.info(f"Patch not compatible: {return_msg}")
            return False, return_msg
    
        installer_compatible, return_msg = installer_check(requirements)
        if not installer_compatible:
            logging.info(f"Patch not compatible: {return_msg}")
            return False, return_msg

    return True, ""

# List files from a GitHub repository
def list_github_files(repo, path):
    url = f"https://api.github.com/repos/{repo}/contents/{path}"

    logging.getLogger('urllib3').setLevel(logging.ERROR)

    files = []
    try:
        response = requests.get(url)
        response.raise_for_status()  # Raise an error for bad responses

        for item in response.json():
            if item['type'] == 'file':
                files.append((item['download_url'], item['path'], 'false'))  # Default executable to false
            elif item['type'] == 'dir':
                # Recursive call for directories
                sub_files = list_github_files(repo, f"{path}/{item['name']}")
                files.extend(sub_files)
    except Exception as e:
        logging.critical(f"Error occurred listing github files for {url} {e=}, {type(e)=}")
    
    return files

# Download files from a GitHub repository
def download_github_files(repo, path, destination_path, ignore, dry_run=False, message = None):
    # Create destination directory if it doesn't exist
    if not dry_run: os.makedirs(destination_path, exist_ok=True)

    # Get the list of files from the GitHub repo
    file_list = list_github_files(repo, path)

    # Separate ignore and include patterns
    ignore_patterns = []
    include_patterns = []

    patterns = ignore.split('|') if ignore else []

    for pattern in patterns:
        if pattern.startswith('!'):
            include_patterns.append(pattern[1:])  # Remove leading '!'
        else:
            ignore_patterns.append(pattern)

    # Process each file
    total_files = len(file_list)
    file_count = 0
    for url, file_path, executable in file_list:
        file_count += 1
        progress = file_count / total_files * 100
        logging.debug(f"file_count={file_count} total_files={total_files} progress={progress}")

        ignore_file = any(re.match(p, file_path) for p in ignore_patterns)
        include_file = any(re.match(p, file_path) for p in include_patterns)

        if ignore_file and not include_file:
            logging.debug(f"Skipping ignored file: {file_path}")
            continue

        destination_file = os.path.join(destination_path, file_path)
        if not dry_run: os.makedirs(os.path.dirname(destination_file), exist_ok=True)  # Create dir if needed

        logging.info(f"Downloading {file_path} to {destination_file}")
        logging.getLogger('urllib3').setLevel(logging.WARNING)
        response = requests.get(url)
        response.raise_for_status()  # Raise an error for bad responses

        # Save the file
        if not dry_run:
            logging.debug(f"Downloading: {progress}% - {file_path}")
            show_message('Installing Patch...', f"Downloading: {file_path}", progress)
            with open(destination_file, 'wb') as f:
                f.write(response.content)

            if executable == "true":
                os.chmod(destination_file, 0o755)  # Make executable

def download_patch_files(message='Download patch definition files?', dry_run=False):
    if (not g_interactive_mode) or show_dialog(message, button_confirm="download"):
        existing_patches = (bool({_ for _ in pathlib.Path(PATCH_LIBRARY_PATH).rglob('*.yml')}) or bool({_ for _ in pathlib.Path(PATCH_LIBRARY_PATH).rglob('*.yaml')}))
        if g_interactive_mode and existing_patches and show_dialog('Remove existing patch definition files?', button_confirm="remove"):
            patch_list = list_patches(PATCH_LIBRARY_PATH, False, skip_invalid=False)
            for patch in patch_list:
                if os.path.isfile(patch['file_path']):
                    logging.debug(f"Removing patch file: {patch['file_path']}")
                    os.remove(patch['file_path'])

        logging.debug(f"Downloading to {os.path.dirname(PATCH_LIBRARY_PATH)}/patches")
        download_github_files(PATCH_REPOSITORY['repository'], PATCH_REPOSITORY['path'], os.path.dirname(PATCH_LIBRARY_PATH), ".*|!.*\.yml|.*\.yaml", dry_run, 'Downloading patch definition files...')
        return True
    return False

# Function to extract ZIP files
def extract_zip(zip_path, destination_path, dry_run=False):
    destination_path = os.path.abspath(destination_path)

    if dry_run:
        logging.info(f"Extract ZIP: {zip_path} to {destination_path}")
        return

    if zipfile.is_zipfile(zip_path):
        #if not os.path.isdir(destination_path):
        #    return False, "Error: Extraction destination path does not exist."
        
        logging.info(f"Extract ZIP: {zip_path} to {destination_path}")

        try:
            with zipfile.ZipFile(zip_path, 'r') as zf:
                filesList = zf.namelist()   
                for idx, file in enumerate(filesList):
                    progress = (idx / len(filesList)) * 100 + 0.001
                    show_message('Installing Patch...', f"Extracting: {os.path.basename(zip_path)}...", progress)
                    zf.extract(file, destination_path)
                zf.close()
        except Exception as e:
            return_msg = f"Error occurred extracting {os.path.basename(zip_path)}.\n{e=}, {type(e)=}"
            logging.critical(return_msg)
            return False, return_msg

        os.remove(zip_path)  # Remove the zip file after extraction
    else:
        return_msg = f"Error: Invalid ZIP: {zip_path}"
        logging.info(return_msg)
        return False, return_msg

    return True, ""    

# Function to download or copy/move files
def download_file(source, destination_path, move=False, dry_run=False, message=None):
    # Check if the source is a URL (assumed if it starts with 'http')
    destination_path = os.path.abspath(destination_path)

    if source.startswith('http'):
        if not is_network_available():
            logging.warning(f"No Network: Unable to download {source}")
            return False

        # Handle downloading from a remote URL
        logging.info(f"Downloading from {source} to {destination_path}")
        if not dry_run:
            os.makedirs(destination_path, exist_ok=True)
        file_name = os.path.join(destination_path, os.path.basename(source))
        
        # Download the file
        logging.getLogger('urllib3').setLevel(logging.WARNING)
        response = requests.get(source, stream=True)
        if response.status_code == 200:
            if not dry_run:
                with open(file_name, 'wb') as file:
                    #total_length = int(response.headers.get('Content-Length', 0))
                    total_length = int(response.headers['Content-Length'])
                    downloaded = 0

                    chunk_size = 1024 * 1024  # 1 MB
                    for chunk in response.iter_content(chunk_size=chunk_size):
                        if chunk:
                            file.write(chunk)
                            downloaded += len(chunk)
                            if message:
                                progress = downloaded / total_length * 100
                                logging.debug(f"file_name={file_name} downloaded={downloaded} total_length={total_length} progress={progress}")
                                show_message(message, f"Downloading {file_name}", progress)

            logging.debug(f"Downloaded: {file_name}")
        else:
            logging.warning(f"Failed to download {source}, status code: {response.status_code}")
            return False
    else:
        # Handle local file copying or moving
        if os.path.isfile(source):
            if move:
                logging.info(f"Moving local file {source} to {destination_path}")
                if not dry_run: shutil.move(source, destination_path)
            else:
                logging.info(f"Copying local file {source} to {destination_path}")
                if not dry_run: shutil.copy(source, destination_path)
        else:
            logging.error(f"Invalid YAML file: Source file missing {source}")
            return False

    return True

# Function to mark files as executable
def make_executable(file_path, dry_run=False):
    file_path = os.path.abspath(file_path)

    logging.info(f"Making {file_path} executable")
    if not dry_run:
        os.chmod(file_path, 0o755)

# Process a specific patch
def process_patch(patch, validate_yaml_only=False, dry_run=False, interactive_mode=False):
    if 'title' in patch and patch['title']:
        if not validate_yaml_only:
            logging.info(f"Processing patch: {patch['title']}")
    else:
        result_msg = f"Invalid YAML file: Missing Title"
        logging.error(result_msg)
        return False, result_msg

    compatible, result_msg = is_patch_compatible(patch)
    if not compatible and not validate_yaml_only:
        logging.warning(result_msg)
        return False, result_msg

    # Process tasks in the order they appear
    for task in patch['tasks']:
        
        # Handle downloads
        if 'files' in task:
            for file in task['files']:
                if file['source'] and file['destination']:
                    if file['source'].startswith('https://github.com/') and not '/raw/' in file['source'] and not '/releases/download/' in file['source'] and not '/releases/latest/download/' in file['source']:
                        logging.info(f"Processing github download for: {file['source']}")
                        if not is_network_available():
                            result_msg = f"No Network: Unable to download {file['source']}"
                            logging.warning(result_msg)
                            return False, result_msg
                        
                        repo_url = file['source'].replace("https://github.com/", "").rstrip('/')
                        path = file.get('github_path', "")
                        ignore = file.get('ignore', "")
                        logging.debug(f"file={file}")
                        if validate_yaml_only and not download_github_files(repo_url, path, file['destination'], ignore, dry_run=True):
                            return False, "Github Validate Failed"
                        else:
                            download_github_files(repo_url, path, file['destination'], ignore, dry_run=dry_run, message='Installing Patch...')
                    else:
                        if validate_yaml_only and not download_file(file['source'], file['destination'], move=file.get('move', False), dry_run=True):
                            return False, "Download Validation Failed"
                        else:
                            download_file(file['source'], file['destination'], move=file.get('move', False), dry_run=dry_run, message='Installing Patch...')        
                else:
                    result_msg = f"Invalid YAML file: Files missing source or destination"
                    logging.error(result_msg)
                    return False, result_msg

        # Handle extraction
        if 'extract' in task:
            for file in task['extract']:
                if file['source'] and file['destination']:
                    if not validate_yaml_only:
                        success, result_msg = extract_zip(file['source'], file['destination'], dry_run)
                        if not success:
                            return False, result_msg
                else:
                    result_msg = f"Invalid YAML file: Extract missing source or destination"
                    logging.error(result_msg)
                    return False, result_msg

        if 'alert' in task:
            for alert_message in task['alert']:
                if interactive_mode:
                    logging.debug(f"Displaying Alert: {alert_message}")
                    show_dialog(alert_message, continue_only=True)
                else:
                    logging.info(f"Non-interactive Mode Alert: {alert_message}")

        if 'confirm' in task:
            for confirm_message in task['confirm']:
                if interactive_mode:
                    logging.debug(f"Displaying Confirm: {confirm_message}")
                    if not show_dialog(confirm_message):
                        return False, "Patch install aborted."
                else:
                    logging.info(f"Non-interactive Mode Alert: {confirm_message}")

        # Handle marking files as executable
        if 'executable' in task:
            for file in task['executable']:
                if file['path']:
                    if not validate_yaml_only:
                        make_executable(file['path'], dry_run)
                else:
                    result_msg = f"Invalid YAML file: Executable missing path"
                    logging.error(result_msg)
                    return False, result_msg

        if 'version_check' in task:
            show_message("Checking version...")
            for check in task['version_check']:
                logging.debug(f"{check}")
                if check['local'] and check['remote']:
                    result = run_command(check['local'])
                    if result:
                        version_local=result.stdout.strip()
                    
                    if version_local and len(version_local) > 0:
                        result = run_command(check['remote'])
                        if result:
                            version_remote=result.stdout.strip()
                        if version_remote and len(version_remote) > 0:
                            if version_tuple(version_local) == version_tuple(version_remote):
                                logging.debug("Versions Check Matched {version_local}")
                                if show_dialog(f"Version up-to-date ({version_remote})\n\nDo you want to install anyways?", button_confirm="install"):
                                    continue
                                else:
                                    return False, None
                            elif version_tuple(version_local) < version_tuple(version_remote):
                                logging.debug(f"Remote version ({version_remote}) newer than Local version ({version_local})")
                                if show_dialog(f"New version available ({version_remote})\n\nDo you want to install?", button_confirm="install"):
                                    continue
                                else:
                                    return False, None
                            else:
                                logging.info(f"Local version ({version_local}) does not match remote version ({version_remote})")
                                if show_dialog(f"Local version ({version_local}) does not match remote version ({version_remote})\n\nDo you want to install remote version?", button_confirm="install"):
                                    continue
                                else:
                                    return False, None
                        else:
                            result_msg = f"Problem retrieving remove version."
                            logging.error(result_msg)
                            return False, result_msg
                    else:
                        logging.debug(f"Not installed.")
                        continue

        # Handle launch commands
        if 'commands' in task and not validate_yaml_only:
            for idx, command in enumerate(task['commands']):
                progress = (idx / len(task['commands'])) * 100 + 0.001
                show_message('Installing Patch...', f"Executing {(idx + 1)} of {len(task['commands'])}...", progress, f"Executing command: {command}")
                if not dry_run:
                    result = run_command(command)

        if 'reboot' in task:
            reboot = True
            if interactive_mode:
                reboot = show_dialog('About to Reboot. Do you want to proceed?', button_confirm="reboot")

            if reboot:
                logging.info(f"Rebooting")
                os.system('reboot')

    result_msg = f"Patch Validation Complete" if validate_yaml_only else f"Patch Installation Complete" 
    return True, result_msg

# Process patches based on the YAML file
def process_patches(patch_file, patch_id=None, dry_run=False, interactive_mode=False):
    logging.info(f"Processing Patch File: {patch_file}")

    # Load the YAML file
    if os.path.isfile(patch_file):
        with open(patch_file, 'r') as file:
            patches = yaml.safe_load(file)
    else:
        result_msg = f"Patch file does not exist ({patch_file})"
        logging.critical(result_msg)
        return False, result_msg

    logging.debug(f"patch_id={patch_id}")
    if patch_id:
        patch = next((p for p in patches if p.get('id') == patch_id), None)
        if patch:
            result, result_msg = process_patch(patch, dry_run=dry_run, interactive_mode=interactive_mode)
        else:
            result_msg = f"No patch found with ID: {patch_id}"
            logging.error(result_msg)
            return False, result_msg
    else:
        for patch in patches:
            result, result_msg = process_patch(patch, dry_run=dry_run, interactive_mode=interactive_mode)

    return result, result_msg

def validate_patch_file(patch_file):
    logging.debug(f"Validating patch file: {patch_file}")

    # Load the YAML file
    if os.path.isfile(patch_file):
        try:
            with open(patch_file, 'r') as file:
                patches = yaml.safe_load(file)
        except Exception as e:
            logging.critical(f"Error occurred loading Patch file ({patch_file}) {e=}, {type(e)=}")
            return False

        try:
            for patch in patches:
                if not process_patch(patch, validate_yaml_only=True, dry_run=True, interactive_mode=False):
                    return False
        except Exception as e:
            logging.critical(f"Error occurred validating Patch file ({patch_file}) {e=}, {type(e)=}")
            return False
    else:
        logging.critical(f"Patch file does not exist ({patch_file})")
        return False

    return True

def list_patches(directory, full_check=False, compatibility_check=True, skip_invalid=False):
    """
    Checks all YAML files (.yml, .yaml) in a given directory for validity.
    
    :param directory: The directory containing patch definition files.
    :param full_check: Boolean, if True, perform a full validity check.
    :return: A list of dictionaries containing filename, patch title, patch ID, and validity status.
    """

    show_message('Loading patch definition files...')

    patches_info = []
    
    if not os.path.isdir(directory):
        return patches_info

    # Look for .yml and .yaml files in the directory
    for filename in os.listdir(directory):
        if filename.endswith(('.yml', '.yaml')):
            file_path = os.path.join(directory, filename)
            logging.debug(f"Checking {file_path}")

            try:
                with open(file_path, 'r') as file:
                    patches = yaml.safe_load(file)
                    
                    if not patches:
                        logging.info(f"No patches found in patch file ({filename})")
                        continue

                    # Check if the YAML contains a title (if not, skip the file)
                    for patch in patches:
                        if 'title' not in patch:
                            logging.debug(f"No Title")
                            continue
                        # Extract title and patch ID
                        patch_title = patch.get('title', 'Unknown Title')
                        patch_id = patch.get('id', None)
                        description = patch.get('description', 'Description not available.')

                        # Perform a full check if requested
                        is_valid = True
                        if full_check:
                            is_valid = process_patch(patch, validate_yaml_only=True, dry_run=True, interactive_mode=False)
                        elif compatibility_check:
                            is_valid, return_msg = is_patch_compatible(patch)

                        # Append the result for this file
                        if is_valid or not skip_invalid:
                            patches_info.append({
                                'filename': filename,
                                'file_path': file_path,
                                'title': patch_title,
                                'patch_id': patch_id,
                                'description': description,
                                'is_valid': is_valid
                            })
            except yaml.YAMLError as e:
                logging.error(f"YAML error in file {filename}: {e}")
                if not skip_invalid:
                    patches_info.append({
                        'filename': filename,
                        'file_path': file_path,
                        'title': 'Invalid YAML Syntax',
                        'patch_id': None,
                        'description': 'Description not available.',
                        'is_valid': False
                    })

    return patches_info

def deduplicate_patches(patch_list):
    # Check if patch_list is None or empty
    if patch_list is None:
        return []
    
    seen_combinations = set()
    final_result = []
    
    for item in reversed(patch_list):
        file_name = os.path.basename(item['file_path'])  # Extract file name from file_path
        combo_key = (item['patch_id'], file_name)  # Create combination of patch_id and file name
        
        if combo_key not in seen_combinations:
            seen_combinations.add(combo_key)
            final_result.append(item)
    
    # Reverse the result to preserve original order after removing first 'file_path'
    final_result.reverse()
    
    return final_result

def draw_text(text, font, color, surface, x, y):
    """Helper function to render text on the screen."""
    text_obj = font.render(text, True, color)
    surface.blit(text_obj, (x, y))

# Function to wrap text based on available width
def wrap_text(text, font, max_width, cut_off=False):
    paragraphs = text.split('\n')
    lines = []

    for paragraph in paragraphs:
        current_line = ''
        words = paragraph.split(' ')
        for word in words:
            prev_test_line = current_line
            test_line = f"{current_line} {word}".strip()
            # Check if current line fits within max width
            if font.size(test_line)[0] <= max_width:
                current_line = test_line
            else:
                if cut_off:
                    current_line = f"{prev_test_line} "
                    for char in word:
                        test_line = f"{current_line}{char}"
                        if font.size(f"{test_line}...")[0] <= max_width:
                            current_line = test_line
                        else:
                            return f"{current_line.strip()}..."
                else:
                    lines.append(current_line)
                    current_line = word

        if cut_off:
            return current_line
        else:
            if current_line:  # Add last line if not empty
                lines.append(current_line)

        lines.append('')

    return lines

def draw_list(list, list_rect, cursor_item, selection_list=True, lock_top=False):
    max_list_display_count = ((list_rect.height - PADDING // 2) // FONT_SIZE)
    if selection_list:
        list_offset = 0
        if len(list) > max_list_display_count:
            if cursor_item < (max_list_display_count // 3):
                list_offset =  0
            elif cursor_item > (max_list_display_count * 2 // 3):
                list_offset = max(cursor_item - (max_list_display_count * 2 // 3), 0)
                if list_offset > max(len(list) - max_list_display_count, 0):
                    list_offset = max(len(list) - max_list_display_count, 0)
                #logging.debug(f"len(list)={len(list)} cursor_item={cursor_item} max_list_display_count={max_list_display_count} list_offset={list_offset}")
    else:
        list_offset = max(min(cursor_item, len(list) - max_list_display_count), 0)

    for i, list_item in enumerate(list):
        if list_offset <= i and (i - list_offset) < max_list_display_count:
            if i == 0 and not selection_list:
                color = BOLD_TEXT_COLOR
            else:
                color = NORMAL_TEXT_COLOR
                if i == cursor_item and selection_list:
                    color = SELECTION_TEXT_COLOR
                    pygame.draw.rect(g_screen, SELECTION_BG_COLOR, pygame.Rect(list_rect.x, list_rect.y + (i - list_offset) * FONT_SIZE - PADDING // 2, g_screen_width // 2 - PADDING * 2, FONT_SIZE))

            if selection_list:
                list_line = wrap_text(list_item, g_normal_font, list_rect.width - PADDING - BORDER * 2, True)
            else:
                list_line = list_item
            draw_text(list_line, g_normal_font, color, g_screen, list_rect.x + PADDING, list_rect.y + (i - list_offset) * FONT_SIZE + 2)

def delete_matching_files(library_path, personal_path):
    # Find all .yaml and .yml files in PATCH_LIBRARY_PATH
    library_files = set()
    
    # Search for .yaml and .yml files in the library path
    for ext in ['*.yaml', '*.yml']:
        library_files.update(os.path.basename(file) for file in glob.glob(os.path.join(library_path, ext)))
    
    # Now check for matching files in PERSONAL_PATCH_DIR and delete if matched
    for ext in ['*.yaml', '*.yml']:
        for personal_file in glob.glob(os.path.join(personal_path, ext)):
            if os.path.basename(personal_file) in library_files:
                logging.info(f"Deleting: {personal_file}")
                os.remove(personal_file)

def patch_migration_check(patch_list_personal):
    if download_patch_files("This version of the Patch Installer uses a new location for downloaded patches.\n\nDo you wish to download updated patch files to the new location and remove the old your patch files?"):
        delete_matching_files(PATCH_LIBRARY_PATH, PERSONAL_PATCH_DIR)

        patch_list = list_patches(PATCH_LIBRARY_PATH, False, skip_invalid=True)
        patch_list_personal = list_patches(PERSONAL_PATCH_DIR, False, skip_invalid=True)
        if len(patch_list_personal) > 0:
            if len(patch_list) == 0:
                patch_list = patch_list_personal
            else:
                patch_list.extend(patch_list_personal)
                patch_list = deduplicate_patches(patch_list)

def main_menu(args, log_level=2):
    dry_run = args.dry_run
    selected_patch = 0
    description_pos = 0
    current_list = 0
    skip_invalid = True
    installing_patch = False
    run = True

    # Load patches
    patch_list = list_patches(PATCH_LIBRARY_PATH, False, skip_invalid=skip_invalid)
    if len(patch_list) == 0:
        logging.warning(f"No patch definition files found at {PATCH_LIBRARY_PATH}")

    patch_list_personal = list_patches(PERSONAL_PATCH_DIR, False, skip_invalid=skip_invalid)
    if len(patch_list_personal) == 0:
        logging.warning(f"No patch definition files found at {PERSONAL_PATCH_DIR}")
    else:
        if len(patch_list) == 0:
            patch_migration_check(patch_list_personal)
            patch_list = patch_list_personal
        else:
            patch_list = deduplicate_patches([*patch_list, *patch_list_personal])

    if len(patch_list) == 0:
        download_patch_files(f"No patch definition files found.\n\nConfirm if you want to download available files?")
        patch_list = list_patches(PATCH_LIBRARY_PATH, False, skip_invalid=skip_invalid)
        if len(patch_list) == 0:
            show_dialog("No patches available. Existing", continue_only=True, button_confirm='Exit')
            run = False

    while run:
        g_screen.fill(BACKGROUND_COLOR)
        
        # Top bar with app title
        title_text = g_normal_font.render(f"Patch Installer v{VERSION}", True, TITLE_TEXT_COLOR)
        pygame.draw.rect(g_screen, TITLE_BG_COLOR, pygame.Rect(0, 0, g_screen_width, g_title_font.get_height()))
        g_screen.blit(title_text, (g_screen_width // 2 - title_text.get_width() // 2, PADDING))

        if dry_run:
            dry_run_instruction = '                      [ Dry Run Mode On ]'
        else:
            dry_run_instruction = ''

        # Bottom bar with instructions
        draw_text(f"Press A to install, B to exit, Arrows to navigate{dry_run_instruction}", g_instruction_font, HIGHLIGHT_COLOR, g_screen, PADDING, g_screen_height - INSTRUCTIONS_HEIGHT)


        # Display patch list on the left half of the screen
        patch_list_height = g_screen_height - TITLE_HEIGHT - INSTRUCTIONS_HEIGHT - PADDING
        patch_list_rect = pygame.Rect(PADDING, TITLE_HEIGHT + PADDING, g_screen_width // 2 - PADDING * 2, patch_list_height)

        # Display selected patch description on the right side
        description_rect = pygame.Rect(g_screen_width // 2 + PADDING, TITLE_HEIGHT + PADDING, g_screen_width // 2 - PADDING * 2, patch_list_height)
        selected_patch_description = f"{patch_list[selected_patch].get('title')}\n{patch_list[selected_patch].get('description', 'No description available.')}"
        description_lines = wrap_text(selected_patch_description, g_normal_font, description_rect.width - PADDING)
        max_description_display_lines = ((description_rect.height - PADDING // 2) // FONT_SIZE)

        # Handle user input
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_b:  # Exit confirmation
                    run = not show_dialog("Are you sure you want to exit?", button_confirm="Exit")
                    if not run:
                        logging.info("Exiting")
                        pygame.quit()
                        trim_logfile(args.log_file)
                        sys.exit()

                elif event.key == pygame.K_DOWN or f"{pygame.key.name(event.key)}" == "[6]":
                    if current_list == 0:
                        selected_patch = (selected_patch + 1) % len(patch_list)
                    else:
                        description_pos = min((description_pos + 1), len(description_lines) - max_description_display_lines)
                elif event.key == pygame.K_UP or f"{pygame.key.name(event.key)}" == "[4]":
                    if current_list == 0:
                        selected_patch = (selected_patch - 1) % len(patch_list)
                    else:
                        description_pos = max((description_pos - 1), 0)
                elif event.key == pygame.K_RIGHT:
                    current_list = 1
                elif event.key == pygame.K_LEFT:
                    current_list = 0
                    description_pos = 0
                elif event.key == pygame.K_SPACE:  # Toggle Dry Run mode
                    dry_run = not dry_run
                elif event.key == pygame.K_x:  # Turn on debug logging
                    logging.info(f"Log Level: {log_level}")
                    logging.getLogger().setLevel(logging.DEBUG)
                    logging.debug("Turned on debug logging")
                    disk_info = get_disk_info()
                    show_dialog("Debug Logging Activated",details=f"Patch Installer: {VERSION}\nBoard: {detect_board()}\nOS: {detect_os(return_raw=True)}\nDisk Info: {disk_info}", continue_only=True)
                elif event.key == pygame.K_y:  # Reload patch definition files
                    download_patch_files()
                    patch_list = list_patches(PATCH_LIBRARY_PATH, False, skip_invalid=skip_invalid)
                    patch_list_personal = list_patches(PERSONAL_PATCH_DIR, False, skip_invalid=skip_invalid)
                    if len(patch_list_personal) > 0:
                        if len(patch_list) == 0:
                            patch_list = patch_list_personal
                        else:
                            patch_list.extend(patch_list_personal)
                            patch_list = deduplicate_patches(patch_list)
                    if selected_patch >= len(patch_list):
                        selected_patch = len(patch_list) - 1
                elif event.key == pygame.K_a:  # Confirm installation
                    installing_patch = confirm_install(patch_list[selected_patch], dry_run)
                else:
                    logging.debug(f"Key pressed: {pygame.key.name(event.key)}")

        pygame.draw.rect(g_screen, TITLE_TEXT_COLOR if current_list == 0 else TITLE_BG_COLOR, pygame.Rect(patch_list_rect.x - PADDING, patch_list_rect.y - PADDING * 2, patch_list_rect.width + PADDING * 2, patch_list_rect.height), BORDER)
        pygame.draw.rect(g_screen, TITLE_TEXT_COLOR if current_list == 1 else TITLE_BG_COLOR, pygame.Rect(description_rect.x - PADDING, description_rect.y - PADDING * 2, description_rect.width + PADDING * 2, description_rect.height), BORDER)
        
        patch_titles = []
        for patch in patch_list:
            patch_titles.append(patch['title'])

        draw_list(patch_titles, patch_list_rect, selected_patch, True)
        draw_list(description_lines, description_rect, description_pos, False, True)

        # Update the screen
        pygame.display.flip()

        # If the user confirms installation, handle it
        if installing_patch:
            show_message('Installing Patch...')
            
            patch_to_install = patch_list[selected_patch]

            result, result_msg = process_patches(patch_to_install['file_path'], patch_id=patch_to_install['patch_id'], dry_run=dry_run, interactive_mode=True)
            if not result and result_msg:
                logging.info(f"Patch failed: {result_msg}")
                result_msg = f"Patch Install Failed: {result_msg}"
            else:
                run = True

            if result_msg:
                show_dialog(result_msg, continue_only=True)

            installing_patch = False

    pygame.quit()
    sys.exit()

def show_message(message, step = None, progress = None, log_message = None):
    if not progress or log_message:
        if not log_message:
            log_message = message
        logging.info(log_message)
    
    if g_interactive_mode:
        g_screen.fill(BACKGROUND_COLOR)
        message_text = g_normal_font.render(message, True, BOLD_TEXT_COLOR)
        g_screen.blit(message_text, (g_screen_width // 2 - message_text.get_width() // 2, (g_screen_height // 2) - (message_text.get_height())))

        if step:
            step_text = g_normal_font.render(step, True, HIGHLIGHT_COLOR)
            progress_step_pos_x = g_screen_width // 10
            progress_step_pos_y = (g_screen_height // 2) + (message_text.get_height() * 2 )
            g_screen.blit(step_text, (progress_step_pos_x, progress_step_pos_y))

        if progress:
            if progress > 100:
                progress = 100
            progress_text = g_normal_font.render(f"{round(progress)}%", True, TITLE_TEXT_COLOR)
            progress_bar_pos_x = g_screen_width // 10
            progress_bar_pos_y = (g_screen_height // 2) + (message_text.get_height() * 2) + (step_text.get_height() * 1.5)
            progress_bar_width = (g_screen_width - (progress_bar_pos_x * 2)) * (progress / 100)
            progress_bar_height = progress_text.get_height() * 1.5
            progress_bar_text_pos_x = (g_screen_width // 2) - (progress_text.get_width() // 2)
            progress_bar_text_pos_y = (g_screen_height // 2) + (message_text.get_height() * 3.75 )

            pygame.draw.rect(g_screen, TITLE_BG_COLOR, pygame.Rect(progress_bar_pos_x, progress_bar_pos_y, progress_bar_width, progress_bar_height))
            g_screen.blit(progress_text, (progress_bar_text_pos_x, progress_bar_text_pos_y))

        pygame.display.flip()

def show_dialog(dialog_msg, details = None, prompt_msg = None, continue_only = False, button_confirm=None, button_cancel="cancel"):
    if not g_interactive_mode:
        logging.log(f"Non-interactive show_dialog: {dialog_msg}")
        logging.debug(f"Non-interactive show_dialog: Returning: {continue_only}")
        return continue_only

    if not button_confirm:
        button_confirm = 'continue' if continue_only else 'confirm'

    dialog_message = wrap_text(dialog_msg, g_normal_font, g_screen_width * 0.80)  # Wrap text to fit screen g_screen_width
    if details:
        details_message = wrap_text(details, g_normal_font, g_screen_width * 0.90)

    DETAILS_SCALE = 0.66
    total_lines = 0
    total_height = 0
    for i, line in enumerate(dialog_message):
        total_height += g_normal_font.render(line, True, BOLD_TEXT_COLOR).get_height()
        total_lines += 1
    if details:
        for i, line in enumerate(details_message):
            total_height += g_details_font.render(line, True, BOLD_TEXT_COLOR).get_height() * DETAILS_SCALE

            total_lines += 1
    total_height = total_height + g_normal_font.render(line, True, BOLD_TEXT_COLOR).get_height() * 2
    total_lines = total_lines + 2

    while True:
        g_screen.fill(BACKGROUND_COLOR)

        text_top = (g_screen_height - total_height) // 2

        msg_height = 0
        for i, line in enumerate(dialog_message):
            message_text = g_normal_font.render(line, True, BOLD_TEXT_COLOR)
            g_screen.blit(message_text, (g_screen_width // 2 - message_text.get_width() // 2, text_top + i * message_text.get_height()))
            msg_height += message_text.get_height()

        text_top += msg_height

        msg_height = 0
        if details:
            for i, line in enumerate(details_message):
                message_text = g_details_font.render(line, True, NORMAL_TEXT_COLOR)
                g_screen.blit(message_text, (g_screen_width * 0.05, text_top + i * message_text.get_height() * DETAILS_SCALE))
                msg_height += message_text.get_height() * DETAILS_SCALE
            text_top += msg_height

        if not prompt_msg:
            if continue_only:
                prompt_msg = f"Press A to {button_confirm}"
            else:
                prompt_msg = f"Press A to {button_confirm}, B to {button_cancel}"

        prompt_text = g_normal_font.render(prompt_msg, True, HIGHLIGHT_COLOR)
        g_screen.blit(prompt_text, (g_screen_width // 2 - prompt_text.get_width() // 2, text_top + message_text.get_height()))

        pygame.display.flip()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                logging.debug(f"Quitting without confirmation")
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                logging.debug(f"Key pressed: {pygame.key.name(event.key)}")
                if event.key == pygame.K_a:  # Confirm exit
                    logging.debug(f"Confirm Selected")
                    #pygame.quit()
                    #sys.exit()
                    return True
                elif event.key == pygame.K_b:  # Cancel exit
                    logging.debug(f"Confirm Canceled")
                    return False

def confirm_install(patch, dry_run=False):
    """Displays a confirmation dialog for patch installation."""
    # Display a confirmation dialog, and return True if confirmed
    # (For now, automatically return True to simulate confirmation)
    dry_run_prefix="[DRY RUN MODE]: " if dry_run else ""
    msg = f"{dry_run_prefix}Are you sure you want to install the \"{patch['title']}\" patch?"
    return show_dialog(msg, button_confirm="install")

# Argument parsing
def parse_arguments():
    parser = argparse.ArgumentParser(description="Patch Installer Tool")
    
    parser.add_argument('patch_file', metavar='<Patch File>', help="Path to the patch YAML or JSON file.", nargs='?')
    parser.add_argument('--patch-id', help="Specify the patch ID if the file contains more than one patch.")
    parser.add_argument('--dry-run', action='store_true', help="Perform a dry run without actually applying the patch.")
    parser.add_argument('-q', '--quiet', action='count', default=0, help="Decrease logging verbosity. Can be used multiple times.")
    parser.add_argument('-v', '--verbose', action='count', default=0, help="Increase logging verbosity. Can be used multiple times.")
    parser.add_argument('--log-file', default=DEFAULT_LOG_FILE, help=f"Specify the log file. Default: {DEFAULT_LOG_FILE}")
    parser.add_argument('--test-mode', action='store_true', help=f"Run in test mode.")

    return parser.parse_args()

def update_check():
    def get_script_version_from_github(script_url):
        response = requests.get(script_url)
        if response.status_code != 200:
            return None

        for line in response.text.splitlines():
            if "VERSION =" in line:
                return line.split("=")[1].strip().replace('"', '').replace("'", "")
        return None

    if is_network_available:
        script_path = os.path.realpath(__file__)
        logging.info(f"{script_path} v{VERSION}")

        github_version = get_script_version_from_github(SCRIPT_SOURCE_URL)
        if github_version and version_tuple(github_version) > version_tuple(VERSION):
            logging.info(f"Newer version ({github_version}) found.")
            if (g_interactive_mode and show_dialog(f"New version {github_version} available.\nUpdate now?",button_confirm="Update", button_cancel="Skip")) or (not g_interactive_mode):
                logging.info(f"Updating to version {github_version}...")

                try:
                    response = requests.get(SCRIPT_SOURCE_URL, timeout=10)
                    if response.status_code == 200:
                        with open(script_path, 'wb') as file:
                            file.write(response.content)
                    else:
                        show_dialog(f"Error: Download Error\n{response.status_code}\nExiting...", continue_only=True, button_confirm='Exit')
                        return False
                except Exception as e:
                    show_dialog(f"Error: Download Failed\n{str(e)}\nExiting...", continue_only=True, button_confirm='Exit')
                    return False

                if show_dialog(f"Update complete.  Restarting", button_confirm="Restart", button_cancel="Skip"):
                    logging.info(f"Restarting...")
                    os.execv(sys.argv[0], sys.argv)
                else:
                    logging.info("Restart canceled.")
    return True

if __name__ == '__main__':
    args = parse_arguments()

    # Default log level is 2 (INFO)
    # Adjust log level based on -q (quiet) and -v (verbose)
    log_level = max(0, min(3, 3 if (args.dry_run or args.test_mode) else 2 + args.verbose - args.quiet))
    initialize_logging(args.log_file, log_level)

     # Process patches with optional patch ID and dry run
    if args.patch_file:
        g_interactive_mode = False

        logging.info(f"Installing Patch: {args.patch_file}")
        if validate_patch_file(args.patch_file):
            process_patches(args.patch_file, args.patch_id, dry_run=args.dry_run)
        else:
            logging.critical(f"Patch Error: There is a problem, check the YAML file before retrying.")
            trim_logfile(args.log_file)
            exit(1)
    else:
        g_interactive_mode=True

        # Initialize Pygame
        pygame.init()

        display_info = pygame.display.Info()

        if args.test_mode:
            g_screen_width = 640
            g_screen_height = 480
        else:
            g_screen_width = display_info.current_w if display_info.current_w else 640
            g_screen_height = display_info.current_h if display_info.current_h else 480

        # Create a screen with size
        g_screen = pygame.display.set_mode((g_screen_width, g_screen_height))
        pygame.display.set_caption("Patch Installer")

        # Fonts
        g_normal_font = pygame.font.SysFont(None, FONT_SIZE)
        g_details_font = pygame.font.SysFont("monospace", 20)
        g_instruction_font = pygame.font.SysFont(None, 24)
        g_title_font = pygame.font.SysFont(None, 48)

        if update_check():
            logging.info(f"Starting Patch Installer...")
            main_menu(args, log_level)

    trim_logfile(args.log_file)
